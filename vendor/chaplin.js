// Generated by CoffeeScript 1.6.3
/*
Chaplin 0.6.0.

Chaplin may be freely distributed under the MIT license.
For all details and documentation:
http://chaplinjs.org
*/


(function() {
  'use strict';
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  require.define({
    'jquery': function(require, exports, module) {
      return module.exports = $;
    },
    'underscore': function(require, exports, module) {
      return module.exports = _;
    },
    'backbone': function(require, exports, module) {
      return module.exports = Backbone;
    }
  });

  require.define({
    'chaplin/application': function(exports, require, module) {
      var Application, Backbone, Dispatcher, EventBroker, Layout, Router, mediator;
      Backbone = require('backbone');
      mediator = require('chaplin/mediator');
      Dispatcher = require('chaplin/dispatcher');
      Layout = require('chaplin/views/layout');
      Router = require('chaplin/lib/router');
      EventBroker = require('chaplin/lib/event_broker');
      return module.exports = Application = (function() {
        function Application() {}

        Application.extend = Backbone.Model.extend;

        _(Application.prototype).extend(EventBroker);

        Application.prototype.title = '';

        Application.prototype.dispatcher = null;

        Application.prototype.layout = null;

        Application.prototype.router = null;

        Application.prototype.initialize = function() {};

        Application.prototype.initDispatcher = function(options) {
          return this.dispatcher = new Dispatcher(options);
        };

        Application.prototype.initLayout = function(options) {
          if (options == null) {
            options = {};
          }
          if (options.title == null) {
            options.title = this.title;
          }
          return this.layout = new Layout(options);
        };

        Application.prototype.initRouter = function(routes, options) {
          this.router = new Router(options);
          if (typeof routes === "function") {
            routes(this.router.match);
          }
          return this.router.startHistory();
        };

        Application.prototype.disposed = false;

        Application.prototype.dispose = function() {
          var prop, properties, _i, _len;
          if (this.disposed) {
            return;
          }
          properties = ['dispatcher', 'layout', 'router'];
          for (_i = 0, _len = properties.length; _i < _len; _i++) {
            prop = properties[_i];
            if (!(this[prop] != null)) {
              continue;
            }
            this[prop].dispose();
            delete this[prop];
          }
          this.disposed = true;
          return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
        };

        return Application;

      })();
    }
  });

  require.define({
    'chaplin/mediator': function(exports, require, module) {
      var Backbone, mediator, support, utils, _;
      _ = require('underscore');
      Backbone = require('backbone');
      support = require('chaplin/lib/support');
      utils = require('chaplin/lib/utils');
      mediator = {};
      mediator.subscribe = Backbone.Events.on;
      mediator.unsubscribe = Backbone.Events.off;
      mediator.publish = Backbone.Events.trigger;
      mediator._callbacks = null;
      utils.readonly(mediator, 'subscribe', 'unsubscribe', 'publish');
      mediator.seal = function() {
        if (support.propertyDescriptors && Object.seal) {
          return Object.seal(mediator);
        }
      };
      utils.readonly(mediator, 'seal');
      return module.exports = mediator;
    }
  });

  require.define({
    'chaplin/dispatcher': function(exports, require, module) {
      var Backbone, Dispatcher, EventBroker, utils, _;
      _ = require('underscore');
      Backbone = require('backbone');
      utils = require('chaplin/lib/utils');
      EventBroker = require('chaplin/lib/event_broker');
      return module.exports = Dispatcher = (function() {
        Dispatcher.extend = Backbone.Model.extend;

        _(Dispatcher.prototype).extend(EventBroker);

        Dispatcher.prototype.previousControllerName = null;

        Dispatcher.prototype.currentControllerName = null;

        Dispatcher.prototype.currentController = null;

        Dispatcher.prototype.currentAction = null;

        Dispatcher.prototype.currentParams = null;

        Dispatcher.prototype.url = null;

        function Dispatcher() {
          this.initialize.apply(this, arguments);
        }

        Dispatcher.prototype.initialize = function(options) {
          if (options == null) {
            options = {};
          }
          this.settings = _(options).defaults({
            controllerPath: 'controllers/',
            controllerSuffix: '_controller'
          });
          return this.subscribeEvent('matchRoute', this.matchRoute);
        };

        Dispatcher.prototype.matchRoute = function(route, params, options) {
          return this.startupController(route.controller, route.action, params, options);
        };

        Dispatcher.prototype.startupController = function(controllerName, action, params, options) {
          var handler, isSameController;
          if (action == null) {
            action = 'index';
          }
          if (params == null) {
            params = {};
          }
          if (options == null) {
            options = {};
          }
          if (options.changeURL !== false) {
            options.changeURL = true;
          }
          if (options.forceStartup !== true) {
            options.forceStartup = false;
          }
          isSameController = !options.forceStartup && this.currentControllerName === controllerName && this.currentAction === action && (!this.currentParams || _(params).isEqual(this.currentParams));
          if (isSameController) {
            return;
          }
          handler = _(this.controllerLoaded).bind(this, controllerName, action, params, options);
          return this.loadController(controllerName, handler);
        };

        Dispatcher.prototype.loadController = function(controllerName, handler) {
          var controllerFileName, path;
          controllerFileName = utils.underscorize(controllerName) + this.settings.controllerSuffix;
          path = this.settings.controllerPath + controllerFileName;
          if (typeof define !== "undefined" && define !== null ? define.amd : void 0) {
            return require([path], handler);
          } else {
            return handler(require(path));
          }
        };

        Dispatcher.prototype.controllerLoaded = function(controllerName, action, params, options, ControllerConstructor) {
          var controller, currentControllerName, method;
          currentControllerName = this.currentControllerName || null;
          controller = new ControllerConstructor(params, currentControllerName);
          method = controller.beforeAction ? 'executeBeforeActionChain' : 'executeAction';
          return this[method](controller, controllerName, action, params, options);
        };

        Dispatcher.prototype.executeAction = function(controller, controllerName, action, params, options) {
          var currentController, currentControllerName;
          currentControllerName = this.currentControllerName || null;
          currentController = this.currentController || null;
          this.previousControllerName = currentControllerName;
          if (currentController) {
            this.publishEvent('beforeControllerDispose', currentController);
            currentController.dispose(params, controllerName);
          }
          controller[action](params, currentControllerName);
          if (controller.redirected) {
            return;
          }
          this.currentControllerName = controllerName;
          this.currentController = controller;
          this.currentAction = action;
          this.currentParams = params;
          this.adjustURL(controller, params, options);
          return this.publishEvent('startupController', {
            previousControllerName: this.previousControllerName,
            controller: this.currentController,
            controllerName: this.currentControllerName,
            params: this.currentParams
          });
        };

        Dispatcher.prototype.executeBeforeActionChain = function(controller, controllerName, action, params) {
          var acts, args, beforeAction, beforeActions, name, next, prototype, prototypeChain, _i, _len, _ref,
            _this = this;
          beforeActions = [];
          args = arguments;
          prototypeChain = utils.getPrototypeChain(controller);
          _ref = prototypeChain.reverse();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            prototype = _ref[_i];
            acts = prototype.beforeAction;
            for (name in acts) {
              beforeAction = acts[name];
              if (__indexOf.call(beforeActions, beforeAction) < 0) {
                if (name === action || RegExp("^" + name + "$").test(action)) {
                  if (typeof beforeAction === 'string') {
                    beforeAction = controller[beforeAction];
                  }
                  if (typeof beforeAction !== 'function') {
                    throw new Error('Controller#executeBeforeActionChain: ' + ("" + beforeAction + " is not a valid beforeAction method for " + name + "."));
                  }
                  beforeActions.push(beforeAction);
                }
              }
            }
          }
          next = function(method, previous) {
            if (previous == null) {
              previous = null;
            }
            if (controller.redirected) {
              return _this.adjustURL(controller, params, {});
            }
            if (!method) {
              return _this.executeAction.apply(_this, args);
            }
            previous = method.call(controller, params, previous);
            if (previous && typeof previous.then === 'function') {
              return previous.then(function(data) {
                return next(beforeActions.shift(), data);
              });
            } else {
              return next(beforeActions.shift(), previous);
            }
          };
          return next(beforeActions.shift());
        };

        Dispatcher.prototype.adjustURL = function(controller, params, options) {
          var url;
          if (typeof options.path === 'string') {
            url = options.path;
          }
          if (options.changeURL) {
            this.publishEvent('!router:changeURL', url, options);
          }
          return this.url = url;
        };

        Dispatcher.prototype.disposed = false;

        Dispatcher.prototype.dispose = function() {
          if (this.disposed) {
            return;
          }
          this.unsubscribeAllEvents();
          this.disposed = true;
          return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
        };

        return Dispatcher;

      })();
    }
  });

  require.define({
    'chaplin/controllers/controller': function(exports, require, module) {
      var Backbone, Controller, EventBroker, _;
      _ = require('underscore');
      Backbone = require('backbone');
      EventBroker = require('chaplin/lib/event_broker');
      return module.exports = Controller = (function() {
        Controller.extend = Backbone.Model.extend;

        _(Controller.prototype).extend(Backbone.Events);

        _(Controller.prototype).extend(EventBroker);

        Controller.prototype.view = null;

        Controller.prototype.redirected = false;

        function Controller() {
          this.initialize.apply(this, arguments);
        }

        Controller.prototype.initialize = function() {};

        Controller.prototype.adjustTitle = function(subtitle) {
          return this.publishEvent('!adjustTitle', subtitle);
        };

        Controller.prototype.redirectTo = function(url, params, options) {
          this.redirected = true;
          return this.publishEvent('!router:route', url, {}, function(routed) {
            if (!routed) {
              throw new Error('Controller#redirectTo: no route matched');
            }
          });
        };

        Controller.prototype.redirectToRoute = function(name, params, options) {
          this.redirected = true;
          return this.publishEvent('!router:routeByName', name, params, options);
        };

        Controller.prototype.disposed = false;

        Controller.prototype.dispose = function() {
          var obj, prop, properties, _i, _len;
          if (this.disposed) {
            return;
          }
          for (prop in this) {
            if (!__hasProp.call(this, prop)) continue;
            obj = this[prop];
            if (obj && typeof obj.dispose === 'function') {
              obj.dispose();
              delete this[prop];
            }
          }
          this.unsubscribeAllEvents();
          properties = ['redirected'];
          for (_i = 0, _len = properties.length; _i < _len; _i++) {
            prop = properties[_i];
            delete this[prop];
          }
          this.disposed = true;
          return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
        };

        return Controller;

      })();
    }
  });

  require.define({
    'chaplin/models/collection': function(exports, require, module) {
      var Backbone, Collection, EventBroker, Model, _, _ref;
      _ = require('underscore');
      Backbone = require('backbone');
      EventBroker = require('chaplin/lib/event_broker');
      Model = require('chaplin/models/model');
      return module.exports = Collection = (function(_super) {
        __extends(Collection, _super);

        function Collection() {
          _ref = Collection.__super__.constructor.apply(this, arguments);
          return _ref;
        }

        _(Collection.prototype).extend(EventBroker);

        Collection.prototype.model = Model;

        Collection.prototype.initDeferred = function() {
          return _(this).extend($.Deferred());
        };

        Collection.prototype.serialize = function() {
          var model, _i, _len, _ref1, _results;
          _ref1 = this.models;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            model = _ref1[_i];
            if (model instanceof Model) {
              _results.push(model.serialize());
            } else {
              _results.push(model.toJSON());
            }
          }
          return _results;
        };

        Collection.prototype.addAtomic = function(models, options) {
          var direction, model;
          if (options == null) {
            options = {};
          }
          if (!models.length) {
            return;
          }
          options.silent = true;
          direction = typeof options.at === 'number' ? 'pop' : 'shift';
          while (model = models[direction]()) {
            this.add(model, options);
          }
          return this.trigger('reset');
        };

        Collection.prototype.disposed = false;

        Collection.prototype.dispose = function() {
          var prop, properties, _i, _len;
          if (this.disposed) {
            return;
          }
          this.trigger('dispose', this);
          this.reset([], {
            silent: true
          });
          this.unsubscribeAllEvents();
          this.off();
          if (typeof this.reject === "function") {
            this.reject();
          }
          properties = ['model', 'models', '_byId', '_byCid', '_callbacks'];
          for (_i = 0, _len = properties.length; _i < _len; _i++) {
            prop = properties[_i];
            delete this[prop];
          }
          this.disposed = true;
          return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
        };

        return Collection;

      })(Backbone.Collection);
    }
  });

  require.define({
    'chaplin/models/model': function(exports, require, module) {
      var Backbone, EventBroker, Model, utils, _, _ref;
      _ = require('underscore');
      Backbone = require('backbone');
      utils = require('chaplin/lib/utils');
      EventBroker = require('chaplin/lib/event_broker');
      return module.exports = Model = (function(_super) {
        var serializeAttributes, serializeModelAttributes;

        __extends(Model, _super);

        function Model() {
          _ref = Model.__super__.constructor.apply(this, arguments);
          return _ref;
        }

        _(Model.prototype).extend(EventBroker);

        Model.prototype.initDeferred = function() {
          return _(this).extend($.Deferred());
        };

        Model.prototype.getAttributes = function() {
          return this.attributes;
        };

        serializeAttributes = function(model, attributes, modelStack) {
          var delegator, key, otherModel, serializedModels, value, _i, _len, _ref1;
          delegator = utils.beget(attributes);
          if (modelStack) {
            modelStack.push(model);
          } else {
            modelStack = [model];
          }
          for (key in attributes) {
            value = attributes[key];
            if (value instanceof Backbone.Model) {
              delegator[key] = serializeModelAttributes(value, model, modelStack);
            } else if (value instanceof Backbone.Collection) {
              serializedModels = [];
              _ref1 = value.models;
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                otherModel = _ref1[_i];
                serializedModels.push(serializeModelAttributes(otherModel, model, modelStack));
              }
              delegator[key] = serializedModels;
            }
          }
          modelStack.pop();
          return delegator;
        };

        serializeModelAttributes = function(model, currentModel, modelStack) {
          var attributes;
          if (model === currentModel || __indexOf.call(modelStack, model) >= 0) {
            return null;
          }
          attributes = typeof model.getAttributes === 'function' ? model.getAttributes() : model.attributes;
          return serializeAttributes(model, attributes, modelStack);
        };

        Model.prototype.serialize = function() {
          return serializeAttributes(this, this.getAttributes());
        };

        Model.prototype.disposed = false;

        Model.prototype.dispose = function() {
          var prop, properties, _i, _len;
          if (this.disposed) {
            return;
          }
          this.trigger('dispose', this);
          this.unsubscribeAllEvents();
          this.off();
          if (typeof this.reject === "function") {
            this.reject();
          }
          properties = ['collection', 'attributes', 'changed', '_escapedAttributes', '_previousAttributes', '_silent', '_pending', '_callbacks'];
          for (_i = 0, _len = properties.length; _i < _len; _i++) {
            prop = properties[_i];
            delete this[prop];
          }
          this.disposed = true;
          return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
        };

        return Model;

      })(Backbone.Model);
    }
  });

  require.define({
    'chaplin/views/layout': function(exports, require, module) {
      var $, Backbone, EventBroker, Layout, utils, _;
      $ = require('jquery');
      _ = require('underscore');
      Backbone = require('backbone');
      utils = require('chaplin/lib/utils');
      EventBroker = require('chaplin/lib/event_broker');
      return module.exports = Layout = (function() {
        Layout.extend = Backbone.Model.extend;

        _(Layout.prototype).extend(EventBroker);

        Layout.prototype.title = '';

        Layout.prototype.events = {};

        Layout.prototype.el = document;

        Layout.prototype.$el = $(document);

        Layout.prototype.cid = 'chaplin-layout';

        function Layout() {
          this.openLink = __bind(this.openLink, this);
          this.initialize.apply(this, arguments);
        }

        Layout.prototype.initialize = function(options) {
          if (options == null) {
            options = {};
          }
          this.title = options.title;
          this.settings = _(options).defaults({
            titleTemplate: _.template("<%= subtitle %> \u2013 <%= title %>"),
            openExternalToBlank: false,
            routeLinks: 'a, .go-to',
            skipRouting: '.noscript',
            scrollTo: [0, 0]
          });
          this.subscribeEvent('beforeControllerDispose', this.hideOldView);
          this.subscribeEvent('startupController', this.showNewView);
          this.subscribeEvent('!adjustTitle', this.adjustTitle);
          if (this.settings.routeLinks) {
            this.startLinkRouting();
          }
          return this.delegateEvents();
        };

        Layout.prototype.delegateEvents = Backbone.View.prototype.delegateEvents;

        Layout.prototype.undelegateEvents = Backbone.View.prototype.undelegateEvents;

        Layout.prototype.hideOldView = function(controller) {
          var scrollTo, view;
          scrollTo = this.settings.scrollTo;
          if (scrollTo) {
            window.scrollTo(scrollTo[0], scrollTo[1]);
          }
          view = controller.view;
          if (view) {
            return view.$el.css('display', 'none');
          }
        };

        Layout.prototype.showNewView = function(context) {
          var view;
          view = context.controller.view;
          if (view) {
            return view.$el.css({
              display: 'block',
              opacity: 1,
              visibility: 'visible'
            });
          }
        };

        Layout.prototype.adjustTitle = function(subtitle) {
          var title;
          if (subtitle == null) {
            subtitle = '';
          }
          title = this.settings.titleTemplate({
            title: this.title,
            subtitle: subtitle
          });
          return setTimeout((function() {
            return document.title = title;
          }), 50);
        };

        Layout.prototype.startLinkRouting = function() {
          if (this.settings.routeLinks) {
            return $(document).on('click', this.settings.routeLinks, this.openLink);
          }
        };

        Layout.prototype.stopLinkRouting = function() {
          if (this.settings.routeLinks) {
            return $(document).off('click', this.settings.routeLinks);
          }
        };

        Layout.prototype.openLink = function(event) {
          var $el, el, href, internal, isAnchor, path, skipRouting, type, _ref, _ref1;
          if (utils.modifierKeyPressed(event)) {
            return;
          }
          el = event.currentTarget;
          $el = $(el);
          isAnchor = el.nodeName === 'A';
          href = $el.attr('href') || $el.data('href') || null;
          if (href === null || href === void 0 || href === '' || href.charAt(0) === '#') {
            return;
          }
          if (isAnchor && ($el.attr('target') === '_blank' || $el.attr('rel') === 'external' || ((_ref = el.protocol) !== 'http:' && _ref !== 'https:' && _ref !== 'file:'))) {
            return;
          }
          skipRouting = this.settings.skipRouting;
          type = typeof skipRouting;
          if (type === 'function' && !skipRouting(href, el) || type === 'string' && $el.is(skipRouting)) {
            return;
          }
          internal = !isAnchor || ((_ref1 = el.hostname) === location.hostname || _ref1 === '');
          if (!internal) {
            if (this.settings.openExternalToBlank) {
              event.preventDefault();
              window.open(el.href);
            }
            return;
          }
          if (isAnchor) {
            path = el.pathname + el.search;
            if (path.charAt(0) !== '/') {
              path = "/" + path;
            }
          } else {
            path = href;
          }
          this.publishEvent('!router:route', path, {}, function(routed) {
            if (routed) {
              event.preventDefault();
            } else if (!isAnchor) {
              location.href = path;
            }
          });
        };

        Layout.prototype.disposed = false;

        Layout.prototype.dispose = function() {
          if (this.disposed) {
            return;
          }
          this.stopLinkRouting();
          this.unsubscribeAllEvents();
          this.undelegateEvents();
          delete this.title;
          this.disposed = true;
          return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
        };

        return Layout;

      })();
    }
  });

  require.define({
    'chaplin/views/view': function(exports, require, module) {
      var $, Backbone, Collection, EventBroker, Model, View, utils, _;
      $ = require('jquery');
      _ = require('underscore');
      Backbone = require('backbone');
      utils = require('chaplin/lib/utils');
      EventBroker = require('chaplin/lib/event_broker');
      Model = require('chaplin/models/model');
      Collection = require('chaplin/models/collection');
      return module.exports = View = (function(_super) {
        __extends(View, _super);

        _(View.prototype).extend(EventBroker);

        View.prototype.autoRender = false;

        View.prototype.container = null;

        View.prototype.containerMethod = 'append';

        View.prototype.subviews = null;

        View.prototype.subviewsByName = null;

        function View(options) {
          if (this.initialize !== View.prototype.initialize) {
            utils.wrapMethod(this, 'initialize');
          }
          if (this.render === View.prototype.render) {
            this.render = _(this.render).bind(this);
          } else {
            utils.wrapMethod(this, 'render');
          }
          if (options) {
            _(this).extend(_.pick(options, ['autoRender', 'container', 'containerMethod']));
          }
          View.__super__.constructor.apply(this, arguments);
        }

        View.prototype.initialize = function(options) {
          this.subviews = [];
          this.subviewsByName = {};
          if (this.model) {
            this.listenTo(this.model, 'dispose', this.dispose);
          }
          if (this.collection) {
            this.listenTo(this.collection, 'dispose', this.dispose);
          }
          if (!this.initializeIsWrapped) {
            return this.afterInitialize();
          }
        };

        View.prototype.afterInitialize = function() {
          if (this.autoRender) {
            return this.render();
          }
        };

        View.prototype.delegate = function(eventType, second, third) {
          var event, events, handler, list, selector;
          if (typeof eventType !== 'string') {
            throw new TypeError('View#delegate: first argument must be a string');
          }
          if (arguments.length === 2) {
            handler = second;
          } else if (arguments.length === 3) {
            selector = second;
            if (typeof selector !== 'string') {
              throw new TypeError('View#delegate: ' + 'second argument must be a string');
            }
            handler = third;
          } else {
            throw new TypeError('View#delegate: ' + 'only two or three arguments are allowed');
          }
          if (typeof handler !== 'function') {
            throw new TypeError('View#delegate: ' + 'handler argument must be function');
          }
          list = (function() {
            var _i, _len, _ref, _results;
            _ref = eventType.split(' ');
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              event = _ref[_i];
              _results.push("" + event + ".delegate" + this.cid);
            }
            return _results;
          }).call(this);
          events = list.join(' ');
          handler = _(handler).bind(this);
          if (selector) {
            this.$el.on(events, selector, handler);
          } else {
            this.$el.on(events, handler);
          }
          return handler;
        };

        View.prototype._delegateEvents = function(events) {
          var eventName, key, match, method, selector, _results;
          if (!(events || (events = getValue(this, 'events')))) {
            return;
          }
          _results = [];
          for (key in events) {
            method = events[key];
            if (!_.isFunction(method)) {
              method = this[method];
            }
            if (!method) {
              throw new Error("Method '" + events[key] + "' does not exist");
            }
            match = key.match(/^(\S+)\s*(.*)$/);
            eventName = match[1];
            selector = match[2];
            method = _.bind(method, this);
            eventName += ".delegateEvents" + this.cid;
            if (selector === '') {
              _results.push(this.$el.bind(eventName, method));
            } else {
              _results.push(this.$el.delegate(selector, eventName, method));
            }
          }
          return _results;
        };

        View.prototype.delegateEvents = function() {
          var _this = this;
          this.undelegateEvents();
          _(utils.getPrototypeChain(this)).chain().pluck('events').compact().uniq().each(function(events) {
            return _this._delegateEvents(events);
          });
        };

        View.prototype.undelegate = function() {
          return this.$el.unbind(".delegate" + this.cid);
        };

        View.prototype.pass = function(attribute, selector) {
          var _this = this;
          return this.listenTo(this.model, "change:" + attribute, function(model, value) {
            var $el;
            $el = _this.$(selector);
            if ($el.is('input, textarea, select, button')) {
              return $el.val(value);
            } else {
              return $el.text(value);
            }
          });
        };

        View.prototype.subview = function(name, view) {
          if (name && view) {
            this.removeSubview(name);
            this.subviews.push(view);
            this.subviewsByName[name] = view;
            return view;
          } else if (name) {
            return this.subviewsByName[name];
          }
        };

        View.prototype.removeSubview = function(nameOrView) {
          var index, name, otherName, otherView, view, _ref;
          if (!nameOrView) {
            return;
          }
          if (typeof nameOrView === 'string') {
            name = nameOrView;
            view = this.subviewsByName[name];
          } else {
            view = nameOrView;
            _ref = this.subviewsByName;
            for (otherName in _ref) {
              otherView = _ref[otherName];
              if (view === otherView) {
                name = otherName;
                break;
              }
            }
          }
          if (!(name && view && view.dispose)) {
            return;
          }
          view.dispose();
          index = _(this.subviews).indexOf(view);
          if (index > -1) {
            this.subviews.splice(index, 1);
          }
          return delete this.subviewsByName[name];
        };

        View.prototype.getTemplateData = function() {
          var items, modelOrCollection, templateData;
          templateData = this.model ? this.model instanceof Model ? this.model.serialize() : utils.beget(this.model.attributes) : this.collection ? (items = this.collection instanceof Collection ? this.collection.serialize() : this.collection.map(function(model) {
            return utils.beget(model.attributes);
          }), {
            items: items
          }) : {};
          modelOrCollection = this.model || this.collection;
          if (modelOrCollection) {
            if (typeof modelOrCollection.state === 'function' && !('resolved' in templateData)) {
              templateData.resolved = modelOrCollection.state() === 'resolved';
            }
            if (typeof modelOrCollection.isSynced === 'function' && !('synced' in templateData)) {
              templateData.synced = modelOrCollection.isSynced();
            }
          }
          return templateData;
        };

        View.prototype.getTemplateFunction = function() {
          throw new Error('View#getTemplateFunction must be overridden');
        };

        View.prototype.render = function() {
          var html, templateFunc;
          if (this.disposed) {
            return false;
          }
          templateFunc = this.getTemplateFunction();
          if (typeof templateFunc === 'function') {
            html = templateFunc(this.getTemplateData());
            this.$el.empty().append(html);
          }
          if (!this.renderIsWrapped) {
            this.afterRender();
          }
          return this;
        };

        View.prototype.afterRender = function() {
          if (this.container) {
            $(this.container)[this.containerMethod](this.el);
            return this.trigger('addedToDOM');
          }
        };

        View.prototype.disposed = false;

        View.prototype.dispose = function() {
          var prop, properties, subview, _i, _j, _len, _len1, _ref;
          if (this.disposed) {
            return;
          }
          if (this.subviews == null) {
            throw new Error('Your `initialize` method must include a super call to\
        Chaplin `initialize`');
          }
          _ref = this.subviews;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            subview = _ref[_i];
            subview.dispose();
          }
          this.unsubscribeAllEvents();
          this.stopListening();
          this.off();
          this.$el.remove();
          properties = ['el', '$el', 'options', 'model', 'collection', 'subviews', 'subviewsByName', '_callbacks'];
          for (_j = 0, _len1 = properties.length; _j < _len1; _j++) {
            prop = properties[_j];
            delete this[prop];
          }
          this.disposed = true;
          return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
        };

        return View;

      })(Backbone.View);
    }
  });

  require.define({
    'chaplin/views/collection_view': function(exports, require, module) {
      var $, CollectionView, View, _;
      $ = require('jquery');
      _ = require('underscore');
      View = require('chaplin/views/view');
      return module.exports = CollectionView = (function(_super) {
        __extends(CollectionView, _super);

        CollectionView.prototype.itemView = null;

        CollectionView.prototype.autoRender = true;

        CollectionView.prototype.renderItems = true;

        CollectionView.prototype.animationDuration = 500;

        CollectionView.prototype.useCssAnimation = false;

        CollectionView.prototype.listSelector = null;

        CollectionView.prototype.$list = null;

        CollectionView.prototype.fallbackSelector = null;

        CollectionView.prototype.$fallback = null;

        CollectionView.prototype.loadingSelector = null;

        CollectionView.prototype.$loading = null;

        CollectionView.prototype.itemSelector = null;

        CollectionView.prototype.filterer = null;

        CollectionView.prototype.filterCallback = function(view, included) {
          var display;
          display = included ? '' : 'none';
          return view.$el.stop(true, true).css('display', display);
        };

        CollectionView.prototype.visibleItems = null;

        function CollectionView(options) {
          this.renderAllItems = __bind(this.renderAllItems, this);
          this.showHideFallback = __bind(this.showHideFallback, this);
          this.itemsResetted = __bind(this.itemsResetted, this);
          this.itemRemoved = __bind(this.itemRemoved, this);
          this.itemAdded = __bind(this.itemAdded, this);
          if (options) {
            _(this).extend(_.pick(options, ['renderItems', 'itemView']));
          }
          CollectionView.__super__.constructor.apply(this, arguments);
        }

        CollectionView.prototype.initialize = function(options) {
          if (options == null) {
            options = {};
          }
          CollectionView.__super__.initialize.apply(this, arguments);
          this.visibleItems = [];
          this.addCollectionListeners();
          if (options.filterer != null) {
            return this.filter(options.filterer);
          }
        };

        CollectionView.prototype.addCollectionListeners = function() {
          this.listenTo(this.collection, 'add', this.itemAdded);
          this.listenTo(this.collection, 'remove', this.itemRemoved);
          return this.listenTo(this.collection, 'reset sort', this.itemsResetted);
        };

        CollectionView.prototype.getTemplateData = function() {
          var templateData;
          templateData = {
            length: this.collection.length
          };
          if (typeof this.collection.state === 'function') {
            templateData.resolved = this.collection.state() === 'resolved';
          }
          if (typeof this.collection.isSynced === 'function') {
            templateData.synced = this.collection.isSynced();
          }
          return templateData;
        };

        CollectionView.prototype.getTemplateFunction = function() {};

        CollectionView.prototype.render = function() {
          CollectionView.__super__.render.apply(this, arguments);
          this.$list = this.listSelector ? this.$(this.listSelector) : this.$el;
          this.initFallback();
          this.initLoadingIndicator();
          if (this.renderItems) {
            return this.renderAllItems();
          }
        };

        CollectionView.prototype.itemAdded = function(item, collection, options) {
          if (options == null) {
            options = {};
          }
          return this.renderAndInsertItem(item, options.index);
        };

        CollectionView.prototype.itemRemoved = function(item) {
          return this.removeViewForItem(item);
        };

        CollectionView.prototype.itemsResetted = function() {
          return this.renderAllItems();
        };

        CollectionView.prototype.initFallback = function() {
          if (!this.fallbackSelector) {
            return;
          }
          this.$fallback = this.$(this.fallbackSelector);
          this.on('visibilityChange', this.showHideFallback);
          this.listenTo(this.collection, 'syncStateChange', this.showHideFallback);
          return this.showHideFallback();
        };

        CollectionView.prototype.showHideFallback = function() {
          var visible;
          visible = this.visibleItems.length === 0 && (typeof this.collection.isSynced === 'function' ? this.collection.isSynced() : true);
          return this.$fallback.css('display', visible ? 'block' : 'none');
        };

        CollectionView.prototype.initLoadingIndicator = function() {
          if (!(this.loadingSelector && typeof this.collection.isSyncing === 'function')) {
            return;
          }
          this.$loading = this.$(this.loadingSelector);
          this.listenTo(this.collection, 'syncStateChange', this.showHideLoadingIndicator);
          return this.showHideLoadingIndicator();
        };

        CollectionView.prototype.showHideLoadingIndicator = function() {
          var visible;
          visible = this.collection.length === 0 && this.collection.isSyncing();
          return this.$loading.css('display', visible ? 'block' : 'none');
        };

        CollectionView.prototype.getItemViews = function() {
          var itemViews, name, view, _ref;
          itemViews = {};
          _ref = this.subviewsByName;
          for (name in _ref) {
            view = _ref[name];
            if (name.slice(0, 9) === 'itemView:') {
              itemViews[name.slice(9)] = view;
            }
          }
          return itemViews;
        };

        CollectionView.prototype.filter = function(filterer, filterCallback) {
          var included, index, item, view, _i, _len, _ref;
          this.filterer = filterer;
          if (filterCallback) {
            this.filterCallback = filterCallback;
          }
          if (filterCallback == null) {
            filterCallback = this.filterCallback;
          }
          if (!_(this.getItemViews()).isEmpty()) {
            _ref = this.collection.models;
            for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
              item = _ref[index];
              included = typeof filterer === 'function' ? filterer(item, index) : true;
              view = this.subview("itemView:" + item.cid);
              if (!view) {
                throw new Error('CollectionView#filter: ' + ("no view found for " + item.cid));
              }
              this.filterCallback(view, included);
              this.updateVisibleItems(view.model, included, false);
            }
          }
          return this.trigger('visibilityChange', this.visibleItems);
        };

        CollectionView.prototype.renderAllItems = function() {
          var cid, index, item, items, remainingViewsByCid, view, _i, _j, _len, _len1, _ref;
          items = this.collection.models;
          this.visibleItems = [];
          remainingViewsByCid = {};
          for (_i = 0, _len = items.length; _i < _len; _i++) {
            item = items[_i];
            view = this.subview("itemView:" + item.cid);
            if (view) {
              remainingViewsByCid[item.cid] = view;
            }
          }
          _ref = this.getItemViews();
          for (cid in _ref) {
            if (!__hasProp.call(_ref, cid)) continue;
            view = _ref[cid];
            if (!(cid in remainingViewsByCid)) {
              this.removeSubview("itemView:" + cid);
            }
          }
          for (index = _j = 0, _len1 = items.length; _j < _len1; index = ++_j) {
            item = items[index];
            view = this.subview("itemView:" + item.cid);
            if (view) {
              this.insertView(item, view, index, false);
            } else {
              this.renderAndInsertItem(item, index);
            }
          }
          if (!items.length) {
            return this.trigger('visibilityChange', this.visibleItems);
          }
        };

        CollectionView.prototype.renderAndInsertItem = function(item, index) {
          var view;
          view = this.renderItem(item);
          return this.insertView(item, view, index);
        };

        CollectionView.prototype.renderItem = function(item) {
          var view;
          view = this.subview("itemView:" + item.cid);
          if (!view) {
            view = this.getView(item);
            this.subview("itemView:" + item.cid, view);
          }
          view.render();
          return view;
        };

        CollectionView.prototype.getView = function(model) {
          if (this.itemView) {
            return new this.itemView({
              model: model
            });
          } else {
            throw new Error('The CollectionView#itemView property ' + 'must be defined or the getView() must be overridden.');
          }
        };

        CollectionView.prototype.insertView = function(item, view, index, enableAnimation) {
          var $list, $next, $previous, $viewEl, children, included, length, position, viewEl,
            _this = this;
          if (index == null) {
            index = null;
          }
          if (enableAnimation == null) {
            enableAnimation = true;
          }
          position = typeof index === 'number' ? index : this.collection.indexOf(item);
          included = typeof this.filterer === 'function' ? this.filterer(item, position) : true;
          viewEl = view.el;
          $viewEl = view.$el;
          if (included) {
            if (enableAnimation) {
              if (this.useCssAnimation) {
                $viewEl.addClass('animated-item-view');
              } else {
                $viewEl.css('opacity', 0);
              }
            }
          } else {
            this.filterCallback(view, included);
          }
          $list = this.$list;
          children = this.itemSelector ? $list.children(this.itemSelector) : $list.children();
          if (children.get(position) !== viewEl) {
            length = children.length;
            if (length === 0 || position === length) {
              $list.append(viewEl);
            } else {
              if (position === 0) {
                $next = children.eq(position);
                $next.before(viewEl);
              } else {
                $previous = children.eq(position - 1);
                $previous.after(viewEl);
              }
            }
          }
          view.trigger('addedToDOM');
          this.updateVisibleItems(item, included);
          if (enableAnimation && included) {
            if (this.useCssAnimation) {
              setTimeout(function() {
                return $viewEl.addClass('animated-item-view-end');
              }, 0);
            } else {
              $viewEl.animate({
                opacity: 1
              }, this.animationDuration);
            }
          }
        };

        CollectionView.prototype.removeViewForItem = function(item) {
          this.updateVisibleItems(item, false);
          return this.removeSubview("itemView:" + item.cid);
        };

        CollectionView.prototype.updateVisibleItems = function(item, includedInFilter, triggerEvent) {
          var includedInVisibleItems, visibilityChanged, visibleItemsIndex;
          if (triggerEvent == null) {
            triggerEvent = true;
          }
          visibilityChanged = false;
          visibleItemsIndex = _(this.visibleItems).indexOf(item);
          includedInVisibleItems = visibleItemsIndex > -1;
          if (includedInFilter && !includedInVisibleItems) {
            this.visibleItems.push(item);
            visibilityChanged = true;
          } else if (!includedInFilter && includedInVisibleItems) {
            this.visibleItems.splice(visibleItemsIndex, 1);
            visibilityChanged = true;
          }
          if (visibilityChanged && triggerEvent) {
            this.trigger('visibilityChange', this.visibleItems);
          }
          return visibilityChanged;
        };

        CollectionView.prototype.dispose = function() {
          var prop, properties, _i, _len;
          if (this.disposed) {
            return;
          }
          properties = ['$list', '$fallback', '$loading', 'visibleItems'];
          for (_i = 0, _len = properties.length; _i < _len; _i++) {
            prop = properties[_i];
            delete this[prop];
          }
          return CollectionView.__super__.dispose.apply(this, arguments);
        };

        return CollectionView;

      })(View);
    }
  });

  require.define({
    'chaplin/lib/route': function(exports, require, module) {
      var Backbone, Controller, EventBroker, Route, _;
      _ = require('underscore');
      Backbone = require('backbone');
      EventBroker = require('chaplin/lib/event_broker');
      Controller = require('chaplin/controllers/controller');
      return module.exports = Route = (function() {
        var escapeRegExp, queryStringFieldSeparator, queryStringValueSeparator, reservedParams;

        Route.extend = Backbone.Model.extend;

        _(Route.prototype).extend(EventBroker);

        reservedParams = ['path', 'changeURL'];

        escapeRegExp = /[-[\]{}()+?.,\\^$|#\s]/g;

        queryStringFieldSeparator = '&';

        queryStringValueSeparator = '=';

        function Route(pattern, controller, action, options) {
          this.pattern = pattern;
          this.controller = controller;
          this.action = action;
          this.options = options != null ? options : {};
          this.handler = __bind(this.handler, this);
          this.addParamName = __bind(this.addParamName, this);
          if (this.options.name != null) {
            this.name = this.options.name;
          }
          this.paramNames = [];
          if (_(Controller.prototype).has(this.action)) {
            throw new Error('Route: You should not use existing controller properties as action names');
          }
          this.createRegExp();
        }

        Route.prototype.reverse = function(params) {
          var index, name, notEnoughParams, url, value, _i, _len, _ref;
          url = this.pattern;
          if (_.isRegExp(url)) {
            return false;
          }
          notEnoughParams = 'Route#reverse: Not enough parameters to reverse';
          if (_.isArray(params)) {
            if (params.length < this.paramNames.length) {
              throw new Error(notEnoughParams);
            }
            index = 0;
            url = url.replace(/[:*][^\/\?]+/g, function(match) {
              var result;
              result = params[index];
              index += 1;
              return result;
            });
          } else {
            _ref = this.paramNames;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              name = _ref[_i];
              value = params[name];
              if (value === void 0) {
                throw new Error(notEnoughParams);
              }
              url = url.replace(RegExp("[:*]" + name, "g"), value);
            }
          }
          if (this.test(url)) {
            return url;
          } else {
            return false;
          }
        };

        Route.prototype.createRegExp = function() {
          var pattern;
          if (_.isRegExp(this.pattern)) {
            this.regExp = this.pattern;
            if (_.isArray(this.options.names)) {
              this.paramNames = this.options.names;
            }
            return;
          }
          pattern = this.pattern.replace(escapeRegExp, '\\$&').replace(/(?::|\*)(\w+)/g, this.addParamName);
          return this.regExp = RegExp("^" + pattern + "(?=\\?|$)");
        };

        Route.prototype.addParamName = function(match, paramName) {
          if (_(reservedParams).include(paramName)) {
            throw new Error("Route#addParamName: parameter name " + paramName + " is reserved");
          }
          this.paramNames.push(paramName);
          if (match.charAt(0) === ':') {
            return '([^\/\?]+)';
          } else {
            return '(.*?)';
          }
        };

        Route.prototype.test = function(path) {
          var constraint, constraints, matched, name, params;
          matched = this.regExp.test(path);
          if (!matched) {
            return false;
          }
          constraints = this.options.constraints;
          if (constraints) {
            params = this.extractParams(path);
            for (name in constraints) {
              if (!__hasProp.call(constraints, name)) continue;
              constraint = constraints[name];
              if (!constraint.test(params[name])) {
                return false;
              }
            }
          }
          return true;
        };

        Route.prototype.handler = function(path, options) {
          var params;
          if (options == null) {
            options = {};
          }
          params = this.buildParams(path);
          options.path = path;
          return this.publishEvent('matchRoute', this, params, options);
        };

        Route.prototype.buildParams = function(path) {
          return _.extend({}, this.extractQueryParams(path), this.extractParams(path), this.options.params);
        };

        Route.prototype.extractParams = function(path) {
          var index, match, matches, paramName, params, _i, _len, _ref;
          params = {};
          matches = this.regExp.exec(path);
          _ref = matches.slice(1);
          for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
            match = _ref[index];
            paramName = this.paramNames.length ? this.paramNames[index] : index;
            params[paramName] = match;
          }
          return params;
        };

        Route.prototype.extractQueryParams = function(path) {
          var current, field, matches, pair, pairs, params, queryString, regExp, value, _i, _len, _ref;
          params = {};
          regExp = /\?(.+?)(?=#|$)/;
          matches = regExp.exec(path);
          if (!matches) {
            return params;
          }
          queryString = matches[1];
          pairs = queryString.split(queryStringFieldSeparator);
          for (_i = 0, _len = pairs.length; _i < _len; _i++) {
            pair = pairs[_i];
            if (!pair.length) {
              continue;
            }
            _ref = pair.split(queryStringValueSeparator), field = _ref[0], value = _ref[1];
            if (!field.length) {
              continue;
            }
            field = decodeURIComponent(field);
            value = decodeURIComponent(value);
            current = params[field];
            if (current) {
              if (current.push) {
                current.push(value);
              } else {
                params[field] = [current, value];
              }
            } else {
              params[field] = value;
            }
          }
          return params;
        };

        return Route;

      })();
    }
  });

  require.define({
    'chaplin/lib/router': function(exports, require, module) {
      var Backbone, EventBroker, Route, Router, mediator, _;
      _ = require('underscore');
      Backbone = require('backbone');
      mediator = require('chaplin/mediator');
      EventBroker = require('chaplin/lib/event_broker');
      Route = require('chaplin/lib/route');
      return module.exports = Router = (function() {
        Router.extend = Backbone.Model.extend;

        _(Router.prototype).extend(EventBroker);

        function Router(options) {
          this.options = options != null ? options : {};
          this.route = __bind(this.route, this);
          this.match = __bind(this.match, this);
          _(this.options).defaults({
            pushState: true
          });
          this.subscribeEvent('!router:route', this.routeHandler);
          this.subscribeEvent('!router:routeByName', this.routeByNameHandler);
          this.subscribeEvent('!router:reverse', this.reverseHandler);
          this.subscribeEvent('!router:changeURL', this.changeURLHandler);
          this.createHistory();
        }

        Router.prototype.createHistory = function() {
          return Backbone.history || (Backbone.history = new Backbone.History());
        };

        Router.prototype.startHistory = function() {
          return Backbone.history.start(this.options);
        };

        Router.prototype.stopHistory = function() {
          if (Backbone.History.started) {
            return Backbone.history.stop();
          }
        };

        Router.prototype.match = function(pattern, target, options) {
          var action, controller, route, _ref;
          if (options == null) {
            options = {};
          }
          if (arguments.length === 2 && typeof target === 'object') {
            options = target;
            controller = options.controller, action = options.action;
            if (!(controller && action)) {
              throw new Error('Router#match must receive either target or options.controller & options.action');
            }
          } else {
            controller = options.controller, action = options.action;
            if (controller || action) {
              throw new Error('Router#match cannot use both target and options.controller / action');
            }
            _ref = target.split('#'), controller = _ref[0], action = _ref[1];
          }
          route = new Route(pattern, controller, action, options);
          Backbone.history.handlers.push({
            route: route,
            callback: route.handler
          });
          return route;
        };

        Router.prototype.route = function(path, options) {
          var handler, _i, _len, _ref;
          if (options == null) {
            options = {};
          }
          _(options).defaults({
            changeURL: true
          });
          path = path.replace(/^(\/#|\/)/, '');
          _ref = Backbone.history.handlers;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            handler = _ref[_i];
            if (handler.route.test(path)) {
              handler.callback(path, options);
              return true;
            }
          }
          return false;
        };

        Router.prototype.reverseHandler = function(name, params, callback) {
          return callback(this.reverse(name, params));
        };

        Router.prototype.reverse = function(name, params) {
          var handler, url, _i, _len, _ref;
          _ref = Backbone.history.handlers;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            handler = _ref[_i];
            if (!(handler.route.name === name)) {
              continue;
            }
            url = handler.route.reverse(params);
            if (url !== false) {
              return url;
            }
          }
          return false;
        };

        Router.prototype.routeHandler = function(path, options, callback) {
          var routed;
          if (arguments.length === 2 && typeof options === 'function') {
            callback = options;
            options = {};
          }
          routed = this.route(path, options);
          return typeof callback === "function" ? callback(routed) : void 0;
        };

        Router.prototype.routeByNameHandler = function(name, params, callback) {
          var path;
          if (arguments.length === 2 && typeof params === 'function') {
            callback = params;
            params = {};
          }
          path = this.reverse(name, params);
          if (!path) {
            return;
          }
          return this.routeHandler(path, callback);
        };

        Router.prototype.changeURL = function(url, options) {
          var navigateOptions;
          if (options == null) {
            options = {};
          }
          navigateOptions = {
            trigger: options.trigger === true,
            replace: options.replace === true
          };
          return Backbone.history.navigate(url, navigateOptions);
        };

        Router.prototype.changeURLHandler = function(url, options) {
          return this.changeURL(url, options);
        };

        Router.prototype.disposed = false;

        Router.prototype.dispose = function() {
          if (this.disposed) {
            return;
          }
          this.stopHistory();
          delete Backbone.history;
          this.unsubscribeAllEvents();
          this.disposed = true;
          return typeof Object.freeze === "function" ? Object.freeze(this) : void 0;
        };

        return Router;

      })();
    }
  });

  require.define({
    'chaplin/lib/delayer': function(exports, require, module) {
      var Delayer;
      Delayer = {
        setTimeout: function(name, time, handler) {
          var handle, wrappedHandler,
            _this = this;
          if (this.timeouts == null) {
            this.timeouts = {};
          }
          this.clearTimeout(name);
          wrappedHandler = function() {
            delete _this.timeouts[name];
            return handler();
          };
          handle = setTimeout(wrappedHandler, time);
          this.timeouts[name] = handle;
          return handle;
        },
        clearTimeout: function(name) {
          if (!(this.timeouts && (this.timeouts[name] != null))) {
            return;
          }
          clearTimeout(this.timeouts[name]);
          delete this.timeouts[name];
        },
        clearAllTimeouts: function() {
          var handle, name, _ref;
          if (!this.timeouts) {
            return;
          }
          _ref = this.timeouts;
          for (name in _ref) {
            handle = _ref[name];
            this.clearTimeout(name);
          }
        },
        setInterval: function(name, time, handler) {
          var handle;
          this.clearInterval(name);
          if (this.intervals == null) {
            this.intervals = {};
          }
          handle = setInterval(handler, time);
          this.intervals[name] = handle;
          return handle;
        },
        clearInterval: function(name) {
          if (!(this.intervals && this.intervals[name])) {
            return;
          }
          clearInterval(this.intervals[name]);
          delete this.intervals[name];
        },
        clearAllIntervals: function() {
          var handle, name, _ref;
          if (!this.intervals) {
            return;
          }
          _ref = this.intervals;
          for (name in _ref) {
            handle = _ref[name];
            this.clearInterval(name);
          }
        },
        clearDelayed: function() {
          this.clearAllTimeouts();
          this.clearAllIntervals();
        }
      };
      if (typeof Object.freeze === "function") {
        Object.freeze(Delayer);
      }
      return module.exports = Delayer;
    }
  });

  require.define({
    'chaplin/lib/event_broker': function(exports, require, module) {
      var EventBroker, mediator;
      mediator = require('chaplin/mediator');
      EventBroker = {
        subscribeEvent: function(type, handler) {
          if (typeof type !== 'string') {
            throw new TypeError('EventBroker#subscribeEvent: ' + 'type argument must be a string');
          }
          if (typeof handler !== 'function') {
            throw new TypeError('EventBroker#subscribeEvent: ' + 'handler argument must be a function');
          }
          mediator.unsubscribe(type, handler, this);
          return mediator.subscribe(type, handler, this);
        },
        unsubscribeEvent: function(type, handler) {
          if (typeof type !== 'string') {
            throw new TypeError('EventBroker#unsubscribeEvent: ' + 'type argument must be a string');
          }
          if (typeof handler !== 'function') {
            throw new TypeError('EventBroker#unsubscribeEvent: ' + 'handler argument must be a function');
          }
          return mediator.unsubscribe(type, handler);
        },
        unsubscribeAllEvents: function() {
          return mediator.unsubscribe(null, null, this);
        },
        publishEvent: function() {
          var args, type;
          type = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (typeof type !== 'string') {
            throw new TypeError('EventBroker#publishEvent: ' + 'type argument must be a string');
          }
          return mediator.publish.apply(mediator, [type].concat(__slice.call(args)));
        }
      };
      if (typeof Object.freeze === "function") {
        Object.freeze(EventBroker);
      }
      return module.exports = EventBroker;
    }
  });

  require.define({
    'chaplin/lib/support': function(exports, require, module) {
      var support;
      support = {
        propertyDescriptors: (function() {
          var error, o;
          if (!(typeof Object.defineProperty === 'function' && typeof Object.defineProperties === 'function')) {
            return false;
          }
          try {
            o = {};
            Object.defineProperty(o, 'foo', {
              value: 'bar'
            });
            return o.foo === 'bar';
          } catch (_error) {
            error = _error;
            return false;
          }
        })()
      };
      return module.exports = support;
    }
  });

  require.define({
    'chaplin/lib/sync_machine': function(exports, require, module) {
      var STATE_CHANGE, SYNCED, SYNCING, SyncMachine, UNSYNCED, event, _fn, _i, _len, _ref;
      UNSYNCED = 'unsynced';
      SYNCING = 'syncing';
      SYNCED = 'synced';
      STATE_CHANGE = 'syncStateChange';
      SyncMachine = {
        _syncState: UNSYNCED,
        _previousSyncState: null,
        syncState: function() {
          return this._syncState;
        },
        isUnsynced: function() {
          return this._syncState === UNSYNCED;
        },
        isSynced: function() {
          return this._syncState === SYNCED;
        },
        isSyncing: function() {
          return this._syncState === SYNCING;
        },
        unsync: function() {
          var _ref;
          if ((_ref = this._syncState) === SYNCING || _ref === SYNCED) {
            this._previousSync = this._syncState;
            this._syncState = UNSYNCED;
            this.trigger(this._syncState, this, this._syncState);
            this.trigger(STATE_CHANGE, this, this._syncState);
          }
        },
        beginSync: function() {
          var _ref;
          if ((_ref = this._syncState) === UNSYNCED || _ref === SYNCED) {
            this._previousSync = this._syncState;
            this._syncState = SYNCING;
            this.trigger(this._syncState, this, this._syncState);
            this.trigger(STATE_CHANGE, this, this._syncState);
          }
        },
        finishSync: function() {
          if (this._syncState === SYNCING) {
            this._previousSync = this._syncState;
            this._syncState = SYNCED;
            this.trigger(this._syncState, this, this._syncState);
            this.trigger(STATE_CHANGE, this, this._syncState);
          }
        },
        abortSync: function() {
          if (this._syncState === SYNCING) {
            this._syncState = this._previousSync;
            this._previousSync = this._syncState;
            this.trigger(this._syncState, this, this._syncState);
            this.trigger(STATE_CHANGE, this, this._syncState);
          }
        }
      };
      _ref = [UNSYNCED, SYNCING, SYNCED, STATE_CHANGE];
      _fn = function(event) {
        return SyncMachine[event] = function(callback, context) {
          if (context == null) {
            context = this;
          }
          this.on(event, callback, context);
          if (this._syncState === event) {
            return callback.call(context);
          }
        };
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        event = _ref[_i];
        _fn(event);
      }
      if (typeof Object.freeze === "function") {
        Object.freeze(SyncMachine);
      }
      return module.exports = SyncMachine;
    }
  });

  require.define({
    'chaplin/lib/utils': function(exports, require, module) {
      var support, utils;
      support = require('chaplin/lib/support');
      utils = {
        beget: (function() {
          var ctor;
          if (typeof Object.create === 'function') {
            return Object.create;
          } else {
            ctor = function() {};
            return function(obj) {
              ctor.prototype = obj;
              return new ctor;
            };
          }
        })(),
        readonly: (function() {
          var readonlyDescriptor;
          if (support.propertyDescriptors) {
            readonlyDescriptor = {
              writable: false,
              enumerable: true,
              configurable: false
            };
            return function() {
              var obj, prop, properties, _i, _len;
              obj = arguments[0], properties = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
              for (_i = 0, _len = properties.length; _i < _len; _i++) {
                prop = properties[_i];
                readonlyDescriptor.value = obj[prop];
                Object.defineProperty(obj, prop, readonlyDescriptor);
              }
              return true;
            };
          } else {
            return function() {
              return false;
            };
          }
        })(),
        getPrototypeChain: function(object) {
          var chain, _ref;
          chain = [object];
          while (object = (_ref = object.constructor) != null ? _ref.__super__ : void 0) {
            chain.push(object);
          }
          return chain;
        },
        wrapMethod: function(instance, name) {
          var func;
          func = instance[name];
          instance["" + name + "IsWrapped"] = true;
          return instance[name] = function() {
            if (instance.disposed) {
              return false;
            }
            func.apply(instance, arguments);
            instance["after" + (utils.upcase(name))].apply(instance, arguments);
            return instance;
          };
        },
        upcase: function(str) {
          return str.charAt(0).toUpperCase() + str.substring(1);
        },
        underscorize: function(string) {
          return string.replace(/[A-Z]/g, function(char, index) {
            return (index !== 0 ? '_' : '') + char.toLowerCase();
          });
        },
        modifierKeyPressed: function(event) {
          return event.shiftKey || event.altKey || event.ctrlKey || event.metaKey;
        }
      };
      if (typeof Object.seal === "function") {
        Object.seal(utils);
      }
      return module.exports = utils;
    }
  });

  require.define({
    'chaplin': function(exports, require, module) {
      var Application, Collection, CollectionView, Controller, Delayer, Dispatcher, EventBroker, Layout, Model, Route, Router, SyncMachine, View, mediator, support, utils;
      Application = require('chaplin/application');
      mediator = require('chaplin/mediator');
      Dispatcher = require('chaplin/dispatcher');
      Controller = require('chaplin/controllers/controller');
      Collection = require('chaplin/models/collection');
      Model = require('chaplin/models/model');
      Layout = require('chaplin/views/layout');
      View = require('chaplin/views/view');
      CollectionView = require('chaplin/views/collection_view');
      Route = require('chaplin/lib/route');
      Router = require('chaplin/lib/router');
      Delayer = require('chaplin/lib/delayer');
      EventBroker = require('chaplin/lib/event_broker');
      support = require('chaplin/lib/support');
      SyncMachine = require('chaplin/lib/sync_machine');
      utils = require('chaplin/lib/utils');
      return module.exports = {
        Application: Application,
        mediator: mediator,
        Dispatcher: Dispatcher,
        Controller: Controller,
        Collection: Collection,
        Model: Model,
        Layout: Layout,
        View: View,
        CollectionView: CollectionView,
        Route: Route,
        Router: Router,
        Delayer: Delayer,
        EventBroker: EventBroker,
        support: support,
        SyncMachine: SyncMachine,
        utils: utils
      };
    }
  });

}).call(this);
